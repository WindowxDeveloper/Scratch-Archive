'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 4 February 2008 at 6:06:11 pm'!Object subclass: #OrderedTreeNode    instanceVariableNames: 'name parent children '    classVariableNames: ''    poolDictionaries: ''    category: 'jens-ScratchXML'!!OrderedTreeNode commentStamp: '<historical>' prior: 0!An OrderedTreeNode features basic high level ordered tree node functionality. Ordered tree nodes may have infinite children and infinite nesting, but should not contains recursive loops. Also, each tree node may only have one single parent node. The top most node having no parent itself is called the root, the lower-most nodes with no children are called leafs. children of the same parent are called siblings. The height of each node describes its distance from the root node.!OrderedTreeNode class    instanceVariableNames: ''!Object subclass: #ScratchXMLConverter    instanceVariableNames: 'target '    classVariableNames: ''    poolDictionaries: ''    category: 'jens-ScratchXML'!OrderedTreeNode subclass: #XMLObject    instanceVariableNames: 'attributes contents '    classVariableNames: ''    poolDictionaries: ''    category: 'jens-ScratchXML'!!XMLObject commentStamp: '<historical>' prior: 0!XMLObject features a basic and simple XML-DOM Model and an easy to use non-validating XML-parser. It also implements a basic high-level user-interface for importing and exporting objects als *.xml-files. Use this class as a simple an easy tool whenever you need your application to store data on disk.!XMLObject class    instanceVariableNames: ''!!BlockMorph methodsFor: 'event handling' stamp: 'jens 2/4/2008 17:35'!rightButtonMenu    | menu |    menu _ CustomMenu new.    menu add: 'help' action: #presentHelpScreen.    menu add: 'export this script' action: #exportXML.    (owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [        menu addLine.        menu add: 'duplicate' action: #duplicate.            (self owner isKindOf: BlockMorph) ifFalse: [  "we can't yet delete a blocks inside a script"            menu add: 'delete' action: #delete]].    DebugMenu ifTrue: [        menu addLine.        menu add: 'show tuples' action: #showTuples].        menu localize; invokeOn: self.! !!CommandBlockMorph methodsFor: 'menus' stamp: 'jens 2/4/2008 17:39'!rightButtonMenu    | menu sFrame choice spec |    menu _ CustomMenu new.    menu add: 'help' action: #presentHelpScreen.    menu add: 'export this script' action: #exportXML.    (owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [        menu addLine.        (#(+ - * / \\) includes: selector) ifTrue: [            #(+ - * / mod) with: #(+ - * / \\) do: [:s :op | menu add: s action: op]].        (#(< = >) includes: selector) ifTrue: [            #(< = >) do: [:op | menu add: op action: op]].        (#(& |) includes: selector) ifTrue: [            #(and or) with: #(& |) do: [:s :op | menu add: s action: op]].        menu addLine.        menu add: 'duplicate' action: #duplicate.        (self owner isKindOf: BlockMorph) ifFalse: [  "can't yet delete a blocks inside a script"            menu add: 'delete' action: #delete]].    sFrame _ self ownerThatIsA: ScratchFrameMorph.    (sFrame notNil and: [#(sensor: sensorPressed:) includes: selector]) ifTrue: [        menu addLine.        menu add: 'show ScratchBoard watcher' action: #showSensorBoard].    DebugMenu ifTrue: [        menu addLine.        menu add: 'show tuples' action: #showTuples].        (choice _ menu localize; startUp) ifNil: [^ self].    (#(presentHelpScreen duplicate delete #exportXML) includes: choice) ifTrue: [^ self perform: choice].    choice = #showSensorBoard ifTrue: [sFrame showSensorBoard. ^ self].    choice = #showTuples ifTrue: [^ self showTuples].    "change operator"    spec _ '%n ', choice, ' %n'.    '\\' = choice    ifTrue: [spec _ '%n mod %n'].    '&' = choice    ifTrue: [spec _ '%b and %b'].    '|' = choice    ifTrue: [spec _ '%b or %b'].    self commandSpec: spec.    self selector: choice.! !!CommandBlockMorph methodsFor: 'xml'!argMorphs    ^ argMorphs! !!CommandBlockMorph methodsFor: 'xml' stamp: 'jens 2/4/2008 16:48'!exportXML    | xml |    xml _ ScratchXMLConverter new target: receiver.    xml exportBlockAsXML: self! !!CommandBlockMorph methodsFor: 'xml' stamp: 'jens 2/4/2008 16:49'!showXML    | xml |    xml _ ScratchXMLConverter new target: receiver.    xml showBlockAsXML: self! !!CBlockMorph methodsFor: 'jens xml'!nestedBlock    ^ nestedBlock! !!EventHatMorph methodsFor: 'xml' stamp: 'jens 2/4/2008 16:47'!exportXML    | xml |    xml _ ScratchXMLConverter new target: self scriptOwner.    xml exportBlockAsXML: self! !!EventHatMorph methodsFor: 'xml' stamp: 'jens 2/4/2008 16:48'!showXML    | xml |    xml _ ScratchXMLConverter new target: self scriptOwner.    xml showBlockAsXML: self! !!ExpressionArgMorph methodsFor: 'xml'!isNumber    ^ isNumber! !!KeyEventHatMorph methodsFor: 'xml'!key    ^ scriptNameMorph choice! !!OrderedTreeNode methodsFor: 'initialize-release' stamp: 'jens 2/18/2007 21:09'!initialize    "private"    super initialize.    children := OrderedCollection new.    name := ''! !!OrderedTreeNode methodsFor: 'testing' stamp: 'jens 1/17/2007 23:08'!isLeaf    ^children isEmpty! !!OrderedTreeNode methodsFor: 'testing' stamp: 'jens 1/17/2007 23:08'!isRoot    ^parent isNil! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 1/18/2007 16:12'!ancestors    "answer a Set containing all recursive parents of the receiver"    self isRoot ifFalse: [        ^(Set with: parent), parent ancestors ].    ^Set new! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 3/6/2007 19:26'!descendents    "answer a Set containing all the receivers children,     their children and so on"    | subtree |    subtree := children asSet.    children        do: [:eachChild | subtree addAll: eachChild descendents].    ^ subtree! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 1/18/2007 16:13'!height    "answer the receiver's distance to its root"    ^self ancestors size! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 5/21/2007 13:00'!lastDescendent    "answer the receiver's last leaf-node"    self isLeaf ifTrue: [^self]    ifFalse: [^(children at: children size) lastDescendent]! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 1/18/2007 16:14'!root    "answer the receiver's topmost tree node"    self isRoot        ifTrue: [ ^self ]        ifFalse: [ ^parent root ]! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 1/18/2007 16:15'!siblings    "answer an OrderedCollection containing all the reveiver's    parent's children without the receiver"        self isRoot        ifTrue: [ ^OrderedCollection new ]        ifFalse: [ ^parent children copyWithout: self ]! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 4/12/2007 18:25'!tree    "answer an OrderedCollection starting with the receiver's parent going    all the way up to root"    self isRoot        ifFalse: [^ ((OrderedCollection with: parent)                , parent tree) ].    ^ OrderedCollection new! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 4/12/2007 18:27'!treeString    "answer a String indicating the receiver's position in the    hierarchy in the form of'root/branch/twig/leaf'"    | nameStream |    nameStream := WriteStream on: String new.    self tree reversed        do: [:eachNode | nameStream nextPutAll: eachNode name;                 nextPutAll: '/'].    ^ nameStream contents! !!OrderedTreeNode methodsFor: 'recursive access' stamp: 'jens 4/12/2007 18:41'!treeStringIndented    "answer a String indicating the receiver's position in the    hierarchy in the form of    'root    -branch    --twig    ---leaf'"    | nameStream |    nameStream := WriteStream on: String new.    self tree reversed        do: [:eachNode |             eachNode height                timesRepeat: [nameStream nextPutAll: String tab].            nameStream nextPutAll: eachNode name;                 nextPutAll: String cr].    ^ nameStream contents! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 2/23/2007 23:57'!addChild: aTreeNode     (aTreeNode = self            or: [self ancestors includes: aTreeNode])        ifTrue: [^ self error: 'loops are not allowed in TreeNodes'].    self privateAddChild: aTreeNode.    aTreeNode privateParent: self! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 1/17/2007 23:10'!children    ^children! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 2/18/2007 21:09'!name    ^name! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 2/18/2007 21:10'!name: aString    name := aString! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 1/17/2007 23:13'!parent    ^parent! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 2/24/2007 00:07'!parent: aTreeNode     (aTreeNode = self            or: [self descendents includes: aTreeNode])        ifTrue: [self error: 'loops are not allowed in TreeNodes'].    parent        ifNotNil: [parent privateRemoveChild: self].    parent := aTreeNode.    parent        ifNotNil: [parent privateAddChild: self]! !!OrderedTreeNode methodsFor: 'variable access' stamp: 'jens 2/24/2007 00:01'!removeChild: aTreeNode     (children includes: aTreeNode)        ifTrue: [children remove: aTreeNode.            aTreeNode privateParent: nil]! !!OrderedTreeNode methodsFor: 'private access' stamp: 'jens 2/23/2007 23:54'!privateAddChild: aNode    (children includes: aNode) ifFalse: [children add: aNode]! !!OrderedTreeNode methodsFor: 'private access' stamp: 'jens 2/23/2007 23:53'!privateParent: aNode    parent := aNode! !!OrderedTreeNode methodsFor: 'private access' stamp: 'jens 2/23/2007 23:55'!privateRemoveChild: aNode     (children includes: aNode)        ifTrue: [children remove: aNode]! !!OrderedTreeNode methodsFor: 'debugging' stamp: 'jens 3/27/2007 20:36'!printOn: aStream     aStream nextPutAll: ' <' , name , '>' , (children                collect: [:child | child name]) asArray printString! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:32'!indexOfChild: aNode    "private"    ^children indexOf: aNode! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:51'!moveChildDown: aNode     | oldidx newidx |    oldidx := self indexOfChild: aNode.    oldidx = children size        ifFalse: [newidx := oldidx + 1.            children swap: newidx with: oldidx]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:57'!moveChildToBottom: aNode     | oldidx newidx |    oldidx := self indexOfChild: aNode.    oldidx = children size        ifFalse: [newidx := children size.            children swap: newidx with: oldidx]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:56'!moveChildToTop: aNode     | oldidx newidx |    oldidx := self indexOfChild: aNode.    oldidx = 1        ifFalse: [newidx := 1.            children swap: newidx with: oldidx]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:46'!moveChildUp: aNode     | oldidx newidx |    oldidx := self indexOfChild: aNode.    oldidx = 1        ifFalse: [newidx := oldidx - 1.            children swap: newidx with: oldidx]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:54'!moveDown    self isRoot        ifFalse: [parent moveChildDown: self]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:57'!moveToBottom    self isRoot        ifFalse: [parent moveChildToBottom: self]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:56'!moveToTop    self isRoot        ifFalse: [parent moveChildToTop: self]! !!OrderedTreeNode methodsFor: 'sorting' stamp: 'jens 2/25/2007 23:48'!moveUpself isRoot ifFalse: [    parent moveChildUp: self]! !!OrderedTreeNode class methodsFor: 'instance creation' stamp: 'jens 2/19/2007 16:24'!named: aString    ^self new        name: aString;        yourself! !!ScratchScriptEditorMorph methodsFor: 'menu/button ops' stamp: 'jens 2/4/2008 16:36'!scriptsMenu    "Present a menu of Scratch script operations."    | menu choice |    self target ifNil: [^ self beep].    menu _ CustomMenu new.    menu add: 'clean up' action: #cleanUp.    menu add: 'save picture of scripts' action: #saveScriptsToImage.    menu addLine.    menu add: 'import a script' action: #importXML.    choice _ menu localize startUp.    choice ifNil: [^ self].    self perform: choice.! !!ScratchScriptEditorMorph methodsFor: 'menu/button ops' stamp: 'jens 2/4/2008 16:36'!scriptsMenu: t1 	| t2 t3 |	self target ifNil: [^ self].	t2 _ CustomMenu new.	t2 add: 'clean up' action: #cleanUp.	t2 add: 'save picture of scripts' action: #saveScriptsToImage.	t2 add: 'add comment' action: #addComment:.	t2 addLine.	t2 add: 'import a script' action: #importXML.	t3 _ t2 localize startUp.	t3 ifNil: [^ self].	t3 = #addComment:		ifTrue: [self perform: t3 with: t1]		ifFalse: [self perform: t3]! !!ScratchScriptEditorMorph methodsFor: 'xml' stamp: 'jens 2/4/2008 16:45'!importXML    | xml script |    xml _ ScratchXMLConverter new target: self target.    script _ xml importBlockFromXML.    script        ifNotNil:             [script openInWorld.            self world activeHand attachMorph: script]! !!ScratchXMLConverter methodsFor: 'generating blocks'!addArgumentBlock: t1 toBlock: t2 at: t3     t2 replaceArgMorph: (t2 argumentAt: t3)        by: t1! !!ScratchXMLConverter methodsFor: 'generating blocks'!blockForEventNamed: t1     t1 = 'Scratch-StartClicked' ifTrue: [^ EventHatMorph new forStartEvent scriptOwner: target].    t1 = 'Scratch-MouseClickEvent' ifTrue: [^ MouseClickEventHatMorph new scriptOwner: target].    t1 = 'Scratch-KeyPressedEvent' ifTrue: [^ KeyEventHatMorph new scriptOwner: target].    ^ EventHatMorph new scriptOwner: target! !!ScratchXMLConverter methodsFor: 'generating blocks'!blockForSelector: t1     | t2 t3 |    t2 _ self target class.    t3 _ t2 blockSpecDict copy.    ^ self target blockFromSpec: (t3 at: t1)        color: (t2 blockColorDict at: t1)! !!ScratchXMLConverter methodsFor: 'generating blocks'!blockForVariableNamed: t1     | t2 |    t2 _ VariableBlockMorph new color: self target variableBlockColor.    t2 receiver: self target blockReceiver;     commandSpec: t1;     selector: #setVar:to:.    ^ t2! !!ScratchXMLConverter methodsFor: 'generating blocks' stamp: 'jens 2/4/2008 17:25'!blockForVariableNamed: t1 selector: t2     | t3 |    t3 _ SetterBlockMorph new color: self target variableBlockColor;             receiver: self target blockReceiver.    t2 asString first = $s        ifTrue: [t3 commandSpec: (ScratchTranslator varSpecTranslationFor: 'set %v to %n' varName: t1);             selector: #setVar:to:]        ifFalse: [t3 commandSpec: (ScratchTranslator varSpecTranslationFor: 'change %v by %n' varName: t1);             selector: #changeVar:by:].    ^ t3! !!ScratchXMLConverter methodsFor: 'generating blocks'!setArgumentInBlock: t1 at: t2 to: t3     | t4 |    t3 size = 0        ifFalse:             [t4 _ t1 argumentAt: t2.            (t4 isKindOf: EventTitleMorph)                ifTrue: [^ t4 eventName: t3].            (t4 isKindOf: ChoiceArgMorph)                ifTrue: [^ t4 choice: t3].            (t4 isKindOf: ExpressionArgMorph)                ifTrue:                     [t4 isNumber ifTrue: [^ t4 numExpression: t3 asNumber].                    ^ t4 stringExpression: t3]].    (t4 isKindOf: ColorArgMorph)        ifTrue: [^ t4 setColor: (Color basicNew setRgb: t3 asNumber)].    (t4 isKindOf: SpriteArgMorph)        ifTrue: [(t3 = 'egde' or: [t3 = 'mouse'])                ifTrue: [^ t4 morph: t3 asSymbol]]! !!ScratchXMLConverter methodsFor: 'accessing'!target    ^ target! !!ScratchXMLConverter methodsFor: 'accessing' stamp: 'jens 2/4/2008 18:02'!target: anObject    target _ anObject! !!ScratchXMLConverter methodsFor: 'xml to block' stamp: 'jens 2/4/2008 18:02'!blockFromXML: xml    ^ self blockFromXMLStack: xml children! !!ScratchXMLConverter methodsFor: 'xml to block'!blockFromXMLStack: t1     | t2 t3 t4 |    t3 _ nil.    t2 _ nil.    t1 do: [:t5 | t5 name = 'block'            ifTrue:                 [t4 _ self singleBlockFromXML: t5.                self setArgumentsForBlock: t4 fromXML: t5.                t2 isNil                    ifTrue: [t2 _ t4]                    ifFalse: [((t3 isKindOf: CBlockMorph)                            or: [t3 isKindOf: IfElseBlockMorph])                            ifTrue: [t3 nextBlock: t4]                            ifFalse: [t3 attachBlock: t4]].                t3 _ t4]].    ^ t2! !!ScratchXMLConverter methodsFor: 'xml to block'!setArgumentsForBlock: t1 fromXML: t2     | t3 t4 t5 t6 |    t4 _ t2 children select: [:t7 | t7 name = 'argument'].    t3 _ 0.    t4 do:         [:t8 |         t3 _ t3 + 1.        t8 isLeaf            ifTrue:                 [t5 _ t8 contents.                self                    setArgumentInBlock: t1                    at: t3                    to: t5]            ifFalse:                 [t6 _ self singleBlockFromXML: t8 children first.                self setArgumentsForBlock: t6 fromXML: t8 children first.                self                    addArgumentBlock: t6                    toBlock: t1                    at: t3]]! !!ScratchXMLConverter methodsFor: 'xml to block'!singleBlockFromXML: t1     | t2 t3 t4 t5 t6 t7 t8 |    t5 _ t1 attributeAt: 'event'.    t4 _ t1 attributeAt: 'variable'.    t3 _ t1 attributeAt: 'selector'.    t3 = 'largerThan' ifTrue: [t3 _ '>'].    t3 = 'lesserThan' ifTrue: [t3 _ '<'].    t3 = 'dividedBy' ifTrue: [t3 _ '/'].    t5 ifNotNil: [^ self blockForEventNamed: t5].    t4        ifNotNil:             [t3 isNil ifTrue: [^ self blockForVariableNamed: t4].            ^ self blockForVariableNamed: t4 selector: t3 asSymbol].    t2 _ self blockForSelector: t3 asSymbol.    (t2 isKindOf: IfElseBlockMorph)        ifTrue:             [t6 _ t1 children detect: [:t9 | t9 name = 'true'].            t7 _ t1 children detect: [:t9 | t9 name = 'false'].            t2 trueBlock: (self blockFromXMLStack: t6 children).            t2 falseBlock: (self blockFromXMLStack: t7 children)]        ifFalse: [(t2 isKindOf: CBlockMorph)                ifTrue:                     [t8 _ self blockFromXMLStack: t1 children.                    t8 ifNotNil: [t2 attachBlock: t8]]].    ^ t2! !!ScratchXMLConverter methodsFor: 'file i/o'!exportBlockAsXML: t1     | t2 t3 t4 |    t4 _ self xmlFromBlock: t1.    t2 _ ScratchFileChooserDialog                chooseNewFileDefault: 'ScratchScript'                title: 'Export Script as XML'                type: #xml.    t2 = #cancelled ifTrue: [^ self].    t2 size = 0 ifTrue: [^ self].    (t2 endsWith: '.xml')        ifFalse: [t2 _ t2 , '.xml'].    t2 _ FileDirectory localNameFor: t2.    t3 _ ScratchFileChooserDialog getLastFolderForType: #xml.    (t3 fileExists: t2)        ifTrue:             [(self confirm: 'Overwrite existing ' , t2 , '?')                ifFalse: [^ self].            t3 deleteFileNamed: t2].    t4 exportToFileDirectory: t3 name: t2! !!ScratchXMLConverter methodsFor: 'file i/o'!importBlockFromXML    | t1 t2 t3 |    t1 _ ScratchFileChooserDialog                chooseExistingFileType: #xml                extensions: #(#xml )                title: 'Import Script from XML'.    t1 = #cancelled ifTrue: [^ nil].    t3 _ FileStream oldFileNamed: t1.    t3 ifNil: [self error: 'could not open ' , t1].    t2 _ XMLObject new importFromFileStream: t3.    t3 close.    ^ self blockFromXML: t2! !!ScratchXMLConverter methodsFor: 'block to xml'!addArgumentsIn: t1 toXML: t2     | t3 |    (t1 isKindOf: CommandBlockMorph)        ifTrue: [t1 argMorphs do:                 [:t4 |                 t3 _ XMLObject named: 'argument'.                ((t4 isKindOf: ExpressionArgMorph)                    or: [t4 isKindOf: ChoiceArgMorph])                    ifTrue: [t3 contents: t4 evaluate asString]                    ifFalse: [(t4 isKindOf: EventTitleMorph)                            ifTrue: [t3 contents: t4 eventName]                            ifFalse: [(t4 isKindOf: BooleanArgMorph)                                    ifFalse: [(t4 isKindOf: ColorArgMorph)                                            ifTrue: [t3 contents: t4 color privateRGB asString]                                            ifFalse: [(t4 isKindOf: SpriteArgMorph)                                                    ifTrue: [t3 contents: t4 morph asString]                                                    ifFalse: [self addBlock: t4 toXML: t3]]]]].                t2 addChild: t3]]        ifFalse: [(t1 isKindOf: KeyEventHatMorph)                ifTrue:                     [t3 _ XMLObject named: 'argument'.                    t3 contents: t1 key.                    t2 addChild: t3]]! !!ScratchXMLConverter methodsFor: 'block to xml'!addBlock: t1 toXML: t2     | t3 t4 |    t3 _ XMLObject named: 'block'.    (t1 isKindOf: EventHatMorph)        ifTrue: [t3 attributeAt: 'event' put: t1 eventName].    (t1 isKindOf: VariableBlockMorph)        ifTrue: [t3 attributeAt: 'variable' put: t1 variable]        ifFalse: [(t1 isKindOf: CommandBlockMorph)                ifTrue:                     [t4 _ t1 selector.                    t4 = #< ifTrue: [t4 _ #lesserThan].                    t4 = #> ifTrue: [t4 _ #largerThan].                    t4 = #/ ifTrue: [t4 _ #dividedBy].                    t3 attributeAt: 'selector' put: t4 asString.                    (t1 isKindOf: SetterBlockMorph)                        ifTrue: [t3 attributeAt: 'variable' put: t1 variable]]].    self addArgumentsIn: t1 toXML: t3.    (t1 isKindOf: CBlockMorph)        ifTrue: [self addNestedBlocksIn: t1 toXML: t3].    (t1 isKindOf: IfElseBlockMorph)        ifTrue: [self addTrueFalseBlocksIn: t1 toXML: t3].    t2 addChild: t3.    t1 nextBlock ifNotNil: [self addBlock: t1 nextBlock toXML: t2].    ^ t2! !!ScratchXMLConverter methodsFor: 'block to xml'!addNestedBlocksIn: t1 toXML: t2     | t3 |    t3 _ t1 nestedBlock.    t3 ifNotNil: [self addBlock: t3 toXML: t2].    ^ t2! !!ScratchXMLConverter methodsFor: 'block to xml'!addTrueFalseBlocksIn: t1 toXML: t2     | t3 t4 t5 t6 |    t4 _ XMLObject named: 'true'.    t6 _ XMLObject named: 'false'.    t1 trueBlockList isEmpty ifFalse: [t3 _ t1 trueBlockList first].    t1 falseBlockList isEmpty ifFalse: [t5 _ t1 falseBlockList first].    t3 ifNotNil: [self addBlock: t3 toXML: t4].    t5 ifNotNil: [self addBlock: t5 toXML: t6].    t2 addChild: t4;     addChild: t6.    ^ t2! !!ScratchXMLConverter methodsFor: 'block to xml'!showBlockAsXML: t1     (self xmlFromBlock: t1) widget! !!ScratchXMLConverter methodsFor: 'block to xml'!xmlFromBlock: t1     | t2 |    t2 _ XMLObject named: 'scratchScript'.    self addBlock: t1 toXML: t2.    ^ t2! !!SpriteArgMorph methodsFor: 'xml'!morph    (morph isKindOf: Symbol)        ifTrue: [^ morph].    ^ morph objName! !!SpriteArgMorph methodsFor: 'xml' stamp: 'jens 2/4/2008 16:45'!morph: anObject    morph _ anObject.    self updateLabel! !!XMLObject methodsFor: 'conversion' stamp: 'jens 1/18/2007 16:20'!encodeEscapeCharacters: aString    "private"    | escdict strg |    strg := aString copy.    escdict := Dictionary new.    escdict        at: $< asString put: '&lt;';        at: $> asString put: '&gt;';        at: $' asString put: '&apos;';        at: $" asString put: '&quot;'.    strg := strg copyReplaceAll: ($& asString) with: '&amp;'.     escdict keysDo: [:escChar |        strg := strg copyReplaceAll: escChar with: (escdict at: escChar) ].    ^strg! !!XMLObject methodsFor: 'conversion' stamp: 'jens 4/17/2007 23:15'!formattedParseString    "answer the receiver's data as a parsable xml-String, which can be    stored as an xml-file. Format the string with tabs and crs to make it    readable in a text-only environment"    | stream |    stream := WriteStream with: String new.    self isRoot        ifTrue: [stream nextPutAll: self documentTag;                 cr].    self isEmpty        ifTrue: [stream nextPutAll: self emptyTag]        ifFalse: [stream nextPutAll: self openingTag.            self hasContents                ifTrue: [stream                        nextPutAll: (self encodeEscapeCharacters: contents)].            self children                do: [:eachChild |                     stream crtab: eachChild height.                    stream nextPutAll: eachChild formattedParseString].            self isLeaf                ifFalse: [stream crtab: self height].            stream nextPutAll: self closingTag].    ^ stream contents! !!XMLObject methodsFor: 'conversion' stamp: 'jens 4/17/2007 22:53'!parseString    "answer the receiver's data as a parsable xml-String, which can be    stored as an xml-file, without any formatting crs and tabs"    | stream |    stream := WriteStream with: String new.    self isRoot        ifTrue: [stream nextPutAll: self documentTag].    self isEmpty        ifTrue: [stream nextPutAll: self emptyTag]        ifFalse: [stream nextPutAll: self openingTag.            self hasContents                ifTrue: [stream                        nextPutAll: (self encodeEscapeCharacters: contents)].            self children                do: [:eachChild | stream nextPutAll: eachChild parseString].            stream nextPutAll: self closingTag].    ^ stream contents! !!XMLObject methodsFor: 'conversion' stamp: 'jens 1/18/2007 16:22'!printString    "answer a description of the receiver to be used primarily for debugging, inspection and exploring"    ^'<', name, '/>'! !!XMLObject methodsFor: 'access' stamp: 'jens 9/10/2007 17:25'!attributeAt: aKeyString     "answer an attribute by its key"    ^ attributes at: aKeyString ifAbsent: [nil]! !!XMLObject methodsFor: 'access' stamp: 'jens 9/10/2007 17:26'!attributeAt: aKeyString put: aValueString    "declare a new attribute for the receiver"    attributes at: aKeyString put: aValueString! !!XMLObject methodsFor: 'access' stamp: 'jens 1/18/2007 16:23'!contents    "answer the receiver's contents string"    ^contents! !!XMLObject methodsFor: 'access' stamp: 'jens 1/18/2007 16:23'!contents: aString    contents := aString! !!XMLObject methodsFor: 'access' stamp: 'jens 1/18/2007 16:24'!removeAttribute: aString    "delete an attribute from the receiver's list"    attributes removeKey: aString! !!XMLObject methodsFor: 'initialize-release' stamp: 'jens 1/18/2007 16:24'!initialize    "private"    super initialize.    name := 'object'.    contents := ''.    attributes := Dictionary new! !!XMLObject methodsFor: 'testing' stamp: 'jens 2/4/2008 16:54'!hasContents    ^contents size > 0! !!XMLObject methodsFor: 'testing' stamp: 'jens 1/11/2007 23:46'!isEmpty    ^self hasContents not and: [ self isLeaf ]! !!XMLObject methodsFor: 'tags' stamp: 'jens 1/18/2007 16:24'!attributeString    "private"    | stream |    stream := WriteStream with: String new.    attributes keysDo: [ :eachKey |        stream nextPutAll: ' ',eachKey, '="' ,(attributes at: eachKey), '"' ].    ^stream contents! !!XMLObject methodsFor: 'tags' stamp: 'jens 1/18/2007 16:25'!closingTag    "private"    ^'</', name, '>'! !!XMLObject methodsFor: 'tags' stamp: 'jens 1/18/2007 16:25'!documentTag    "private"    ^'<?xml version="1.0" encoding="UTF-8" ?>'! !!XMLObject methodsFor: 'tags' stamp: 'jens 1/18/2007 16:25'!emptyTag    "private"    ^'<', name, self attributeString, '/>'! !!XMLObject methodsFor: 'tags' stamp: 'jens 1/18/2007 16:25'!openingTag    "private"    ^'<', name, self attributeString, '>'! !!XMLObject methodsFor: 'import-export' stamp: 'jens 1/18/2007 16:25'!exportToFileDirectory: directory name: fileName    "basic high-level export feature"    (directory fileExists: fileName) ifTrue: [        directory deleteFileNamed: fileName].    (directory fileNamed: fileName)        nextPutAll: self parseString;        close.! !!XMLObject methodsFor: 'import-export' stamp: 'jens 2/4/2008 17:12'!importFromFileStream: aFileStream     "basic high-level import feature"    | source |    aFileStream open.    source _ aFileStream contentsOfEntireFile.    aFileStream close.    self initialize; parseFrom: source! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:26'!attributeMenu    "private"    | menu |    menu := MenuMorph new.    attributes isEmpty        ifTrue: [ menu add: '(./.)' action: nil ]        ifFalse: [ attributes keysDo: [ :eachKey |            menu add: (eachKey, '="' ,(attributes at: eachKey), '"') action: nil ]].    ^menu! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:26'!contentsMenu    "private"    | menu |    menu := MenuMorph new.    contents isEmpty        ifTrue: [ menu add: '(./.)' action: nil ]        ifFalse: [ menu add: contents action: nil ].    ^menu! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:27'!export    "basic gui-export dialog"    self exportToDirectory: FileDirectory default! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:27'!exportToDirectory: aFileDirectory    "use this method if your application keeps track of its current directory"    | result filename dir |     dir := aFileDirectory.    result := ((StandardFileMenu newFileMenu: dir withPattern: '*.*') startUpWithCaption: 'export ',name).    result isNil ifTrue: [ ^self ].    dir := result directory.    filename := result name.    filename size = 0 ifTrue: [^self ].    self exportToFileDirectory: dir name: filename! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:28'!exportWidget    "private"    self        export;        widget! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:28'!import    "basic high-level import gui dialog"    self importFromDirectory: FileDirectory default! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:28'!importFromDirectory: aFileDirectory    "use this method if your application keeps track of its current directory"    | result |    result := StandardFileMenu oldFileStreamFrom: aFileDirectory.    result isNil ifTrue: [ ^self ].    self importFromFileStream: result! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:29'!importWidget    "private"    self        import;        widget! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:29'!menu    "private"    | menu |    menu := MenuMorph entitled: name.    self isLeaf        ifFalse: [            children do: [: eachChild |                menu add: (eachChild name) subMenu: (eachChild menu)]].    menu        addLine;        add: 'attributes' subMenu: (self attributeMenu);        add: 'contents' subMenu: (self contentsMenu).    ^menu! !!XMLObject methodsFor: 'widget' stamp: 'jens 4/17/2007 23:13'!parseStringWidget    "private"    (PopUpMenu labels: self formattedParseString) startUpLeftFlush.    self widget! !!XMLObject methodsFor: 'widget' stamp: 'jens 1/18/2007 16:29'!widget    "simple 'explorer'"    | menu |    menu := MenuMorph entitled: 'Jens Moenig''s XML DOM Widget'.    menu        defaultTarget: self;        add: 'explore ', name subMenu: self menu;        add: 'view parse string ...' action: #parseStringWidget;        add: 'export ', name, ' ...' action: #exportWidget;        add: 'import ...' action: #importWidget;        add: 'close'    action: nil.    menu popUpInWorld! !!XMLObject methodsFor: 'parsing showing progress' stamp: 'jens 10/2/2007 09:00'!parseContentsShowingProgressFrom: aString     "private"    | src begin start stop tag substrings content filtered nestingLevel i |    start := 1.    begin := 1.    src := aString.    substrings := OrderedCollection new.    content := ''.    [start >= src size        or: [begin = 0]]        whileFalse: [begin := src indexOf: $< startingAt: start.            begin = 0                ifFalse: [stop := src                                indexOfAnyOf: (CharacterSet                                        with: Character space                                        with: $>                                        with: $/)                                startingAt: begin                                ifAbsent: [self error: 'xml parser failed'].                    tag := src copyFrom: begin + 1 to: stop - 1.                    start := stop.                    stop := src                                indexOfAnyOf: (CharacterSet with: $/ with: $>)                                startingAt: start                                ifAbsent: [self error: 'xml parser failed'].                    (src at: stop)                            = $/                        ifTrue: [substrings                                add: (src copyFrom: begin to: stop + 1)]                        ifFalse: [nestingLevel := 1.                            [nestingLevel = 0]                                whileFalse: [stop := src findString: tag startingAt: start.                                    (src at: stop - 1)                                            = $/                                        ifTrue: [nestingLevel := nestingLevel - 1.                                            start := stop + tag size.                                            stop := start]                                        ifFalse: [(src at: stop - 1)                                                    = $<                                                ifTrue: [nestingLevel := nestingLevel + 1.                                                    start := stop.                                                    stop := src indexOf: $> startingAt: start.                                                    (src at: stop - 1)                                                            = $/                                                        ifTrue: [nestingLevel := nestingLevel - 1].                                                    start := stop]                                                ifFalse: [start := stop + 1]]].                            substrings                                add: (src copyFrom: begin to: stop).                            start := stop]]].    filtered := self findBetweenSubstrings: substrings in: src.    filtered        do: [:string | content := content , string].    self        contents: (self decodeEscapeCharacters: content).    i := 0.    'Parsing...'        displayProgressAt: Display center        from: i        to: substrings size        during: [:bar | substrings                do: [:substring |                     self                        addChild: (self class parseFrom: substring).                    i := i + 1.                    bar value: i]]! !!XMLObject methodsFor: 'parsing showing progress' stamp: 'jens 9/26/2007 11:41'!parseShowingProgressFrom: aString     "private"    | src start stop tag attribs content index |    start := aString findString: '<?xml'.    start = 0        ifTrue: [start := 1]        ifFalse: [start := start + 6.            stop := aString findString: '?>' startingAt: start.            start := stop + 2].    src := aString copyFrom: start to: aString size.    start := 1.    tag := ''.    [tag = '']        whileTrue: [start := src indexOf: $< startingAt: start.            stop := src                        indexOfAnyOf: (CharacterSet                                with: Character space                                with: $>                                with: $/)                        startingAt: start                        ifAbsent: [self error: 'xml paser failed'].            tag := src copyFrom: start + 1 to: stop - 1.            start := stop.            (((tag at: 1)                            = $?                        or: [(tag at: 1)                                = $-])                    or: [(tag at: 1)                            = $!!])                ifTrue: [tag := '']].    stop := src                indexOfAnyOf: (CharacterSet with: $/ with: $>)                startingAt: start                ifAbsent: [self error: 'xml parser failed'].    start = stop        ifTrue: [attribs := '']        ifFalse: [attribs := src copyFrom: start + 1 to: stop - 1].    start := stop.    (src at: start)            = $/        ifTrue: [content := '']        ifFalse: [            index := src reversed findString: ('</' , tag , '>') reversed.            stop := src size - (index + tag size + 1).            start = stop                ifTrue: [content := '']                ifFalse: [content := src copyFrom: start + 1 to: stop - 1].].    self name: tag;         parseAttributesFrom: attribs;         parseContentsShowingProgressFrom: content! !!XMLObject methodsFor: 'parsing basic' stamp: 'jens 1/18/2007 16:30'!decodeEscapeCharacters: aString    "private"    | escdict strg |    strg := aString copy.    escdict := Dictionary new.    escdict        at: '&amp;' put: $& asString;        at: '&lt;' put: $< asString;        at: '&gt;' put: $> asString;        at: '&apos;' put: $' asString;        at: '&quot;' put: $" asString.    escdict keysDo: [:escChar |        strg := strg copyReplaceAll: escChar with: (escdict at: escChar) ].    ^strg! !!XMLObject methodsFor: 'parsing basic' stamp: 'jens 9/28/2007 12:57'!findBetweenSubstrings: anOrderedCollection in: aString     "private - answer an OrderedCollection containing all Strings    found between those specified in anOrderedCollection"    | start stop found strings |    strings := OrderedCollection new.    start := 1.    anOrderedCollection        do: [:substring |             stop := aString findString: substring startingAt: start.            stop > start                ifTrue: [found := aString copyFrom: start to: stop]                ifFalse: [found := ''].            strings add: found.            start := stop + substring size].    found := aString copyFrom: start to: aString size.    strings add: found.    ^ strings! !!XMLObject methodsFor: 'parsing basic' stamp: 'jens 1/18/2007 16:30'!parseAttributesFrom: aString    "private"    | src start stop key value |    src := aString.    start := 1.    stop := 0.    [stop >= src size ] whileFalse: [        stop := src indexOf: $= startingAt: start.        key := src copyFrom: start to: stop-1.        start := src indexOf: $" startingAt: stop.        stop := src indexOf: $" startingAt: start + 1.        value := src copyFrom: start + 1 to: stop - 1.        start := stop + 2.                stop := stop + 1.        self attributeAt: key put: value ]! !!XMLObject methodsFor: 'parsing basic' stamp: 'jens 9/28/2007 12:57'!parseContentsFrom: aString     "private"    | src begin start stop tag substrings content filtered nestingLevel |    start := 1.    begin := 1.    src := aString.    substrings := OrderedCollection new.    content := ''.    [start >= src size        or: [begin = 0]]        whileFalse: [begin := src indexOf: $< startingAt: start.            begin = 0                ifFalse: [stop := src                                indexOfAnyOf: (CharacterSet                                        with: Character space                                        with: $>                                        with: $/)                                startingAt: begin                                ifAbsent: [self error: 'xml parser failed'].                    tag := src copyFrom: begin + 1 to: stop - 1.                    start := stop.                    stop := src                                indexOfAnyOf: (CharacterSet with: $/ with: $>)                                startingAt: start                                ifAbsent: [self error: 'xml parser failed'].                    (src at: stop)                            = $/                        ifTrue: [substrings                                add: (src copyFrom: begin to: stop + 1)]                        ifFalse: [nestingLevel := 1.                            [nestingLevel = 0]                                whileFalse: [stop := src findString: tag startingAt: start.                                    (src at: stop - 1)                                            = $/                                        ifTrue: [nestingLevel := nestingLevel - 1.                                            start := stop + tag size.                                            stop := start]                                        ifFalse: [(src at: stop - 1)                                                    = $<                                                ifTrue: [nestingLevel := nestingLevel + 1.                                                    start := stop.                                                    stop := src indexOf: $> startingAt: start.                                                    (src at: stop - 1)                                                            = $/                                                        ifTrue: [nestingLevel := nestingLevel - 1].                                                    start := stop]                                                ifFalse: [start := stop + 1]]].                            substrings                                add: (src copyFrom: begin to: stop).                            start := stop]]].    filtered := self findBetweenSubstrings: substrings in: src.    filtered        do: [:string | content := content , string].    self        contents: (self decodeEscapeCharacters: content).    substrings        do: [:substring | self                addChild: (self class parseFrom: substring)]! !!XMLObject methodsFor: 'parsing basic' stamp: 'jens 9/25/2007 11:52'!parseFrom: aString     "private"    | src start stop tag attribs content index |    start := aString findString: '<?xml'.    start = 0        ifTrue: [start := 1]        ifFalse: [start := start + 6.            stop := aString findString: '?>' startingAt: start.            start := stop + 2].    src := aString copyFrom: start to: aString size.    start := 1.    tag := ''.    [tag = '']        whileTrue: [start := src indexOf: $< startingAt: start.            stop := src                        indexOfAnyOf: (CharacterSet                                with: Character space                                with: $>                                with: $/)                        startingAt: start                        ifAbsent: [self error: 'xml paser failed'].            tag := src copyFrom: start + 1 to: stop - 1.            start := stop.            (((tag at: 1)                            = $?                        or: [(tag at: 1)                                = $-])                    or: [(tag at: 1)                            = $!!])                ifTrue: [tag := '']].    stop := src                indexOfAnyOf: (CharacterSet with: $/ with: $>)                startingAt: start                ifAbsent: [self error: 'xml parser failed'].    start = stop        ifTrue: [attribs := '']        ifFalse: [attribs := src copyFrom: start + 1 to: stop - 1].    start := stop.    (src at: start)            = $/        ifTrue: [content := '']        ifFalse: [index := src reversed findString: ('</' , tag , '>') reversed.            stop := src size - (index + tag size + 1).            start = stop                ifTrue: [content := '']                ifFalse: [content := src copyFrom: start + 1 to: stop - 1]].    self name: tag;         parseAttributesFrom: attribs;         parseContentsFrom: content! !!XMLObject class methodsFor: 'demo' stamp: 'jens 1/18/2007 13:20'!widget    self new widget! !!XMLObject class methodsFor: 'instance creation' stamp: 'jens 1/18/2007 13:08'!import    ^self new import; yourself! !!XMLObject class methodsFor: 'instance creation' stamp: 'jens 1/12/2007 23:38'!named: aString contents: aContentString    ^self new        name: aString;        contents: aContentString;        yourself! !!XMLObject class methodsFor: 'instance creation' stamp: 'jens 1/18/2007 00:33'!parseFrom: aString    ^self new parseFrom: aString; yourself! !!XMLObject class methodsFor: 'instance creation' stamp: 'jens 9/28/2007 12:59'!parseShowingProgressFrom: aString     ^ self new parseShowingProgressFrom: aString;         yourself! !